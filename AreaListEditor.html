<!DOCTYPE html>
<!--
to preview:
open -n -a /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --args --disable-web-security --remote-debugging-port=9222 --user-data-dir="/tmp/test"  
-->

<!-- 
Copyright 2023 Neil Sims

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.	
 -->
<html lang="en">

<head>
	<base target="_top">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Area Editor</title>

	<!--  <link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />-->
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
		integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
	<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
	
	<style>
		html,
		body {
			margin: 0px;
			font-family: sans-serif;
			height: 100%;
			width: 100%;
			font-family: sans-serif;
			display: table;
			/* overflow: hidden;  */
		}

		p {
			margin: 15px;
			padding: 0px;
		}

		.rotate90 {
			-moz-transform: rotate(90deg);
			-webkit-transform: rotate(90deg);
			-o-transform: rotate(90deg);
			-ms-transform: rotate(90deg);
            transform: rotate(90deg);
			font-size: 30px;
			padding-bottom: 17px;
			padding-top: 0px;
			padding-left: 10px;
			padding-right: 15px;
			width: 40px;
			height: 40px;
			text-align: center;
			vertical-align: bottom;
		}

		.normal {
			font-size: 30px;
			padding-bottom: 8px;
			padding-top: 0px;
			padding-left: 2px;
			padding-right: 0px;
			width: 40px;
			height: 40px;
			vertical-align: center;
			text-align: center;
		}

		.bin {
			font-size: 20px;
			padding-bottom: 0px;
			padding-top: 0px;
			padding-left: 0px;
			padding-right: 0px;
			width: 40px;
			height: 40px;
			vertical-align: bottom;
			text-align: center;
		}

		.status {
			color: red;
			height: 20px;
			margin: 2px 15px;
		}

		.ok {
			color: blue;
		}


		.commands {
			margin: 2px 15px;
		}

		#areaList {
			box-sizing: border-box;
			border: 2px solid #ccc;
			border-radius: 4px;
			background-color: #f8f8f8;
			width: 480px;
			font-family: monospace;
			margin: 8px 15px;
			padding: 5px;
			padding-left: 10px;
			resize: none;
		}

		#areaList.highlight {
			border-color: blue;
			border-width: 8px;
			margin: 2px 9px;
		}

		.mycontainer {
			display: flex;
			flex-direction: column;
			height: 100%;
		}

		.config {
			background: #f1f1f1;
		}

		.mymap {
			background: #f1f1f1;
			flex-grow: 1;
			min-height: 100px;
			padding: 2px 10px 10px 10px;
		}

		.leaflet-container {
			min-height: 100px;
			height: 100%;
			max-width: 100%;
		}

		.collapsible {
			background-color: #777;
			color: white;
			cursor: pointer;
			padding: 8px;
			width: 100%;
			padding-left: 15px;
			border: none;
			text-align: left;
			outline: none;
			font-size: 15px;
		}

		.active,
		.collapsible:hover {
			background-color: #555;
		}

		.content {
			padding: 0 0px;
			display: none;
			overflow: hidden;
			background-color: #f1f1f1;
		}

		.collapsible:after {
			content: '+';
			font-size: 15px;
			color: white;
			float: right;
			margin-left: 5px;
		}

		.active:after {
			content: "-";
			color: white;
		}
	</style>


</head>

<body>
	<div class="mycontainer">
		<div class="config">
			<button type="button" class="collapsible active">Splitter area.list editor</button>
			<div class="content" style="display: block;">
				<p>
					Allows manual editing of the area.list file that is generated by the mkgmap splitter program.</li>
				<ol>
					<li> Copy and paste the text from an area.list file into the edit box, or drag an area.list file
						into the edit box. A minimal example is provided by default. </li>
					<li> Click Reprocess </li>
					<li> Drag the area boundaries as needed </li>
					<li> Click on the area centres to delete or subdivide each area </li>
					<li> Click download to save a local copy of the new area.list file </li>
					<li> Rerun the splitter command with the argument --split-file=areas.list </li>
				</ol>
				</p>
			</div>
			<button type="button" class="collapsible active">Area.List</button>
			<div class="content" style="display: block;">
				<textarea id="areaList" name="inputArea" rows="4" cols="80">
42004059: 2371584,-122880 to 2392064,-88064 
42004060: 2371584,-88064 to 2392064,-67584 
42004062: 2371584,-67584 to 2381824,-47104 
42004063: 2381824,-67584 to 2392064,-47104 </textarea>
			</div>
			<div id="statusMessage" class="status">&nbsp;</div>
			<div class="commands">
				<button type="button" onclick="readArea()">Reprocess</button>
				<button type="button" onclick="undo.undo()" id="undo" disabled>Undo</button>
				<button type="button" onclick="downloadNow()">Download</button>
			</div>
		</div>
		<div class="mymap">
			<div id="map"></div>
		</div>
	</div>
	<script>
/** global variable that hold the leaflet map */
const map = L.map('map').setView([51.505, -0.09], 7);
/** global layerGroup to hold the area drawings */
var areaLayer = L.layerGroup([])
/** global layerGroup to hold the area drawings */
var edgeLayer = L.layerGroup([])
/** global array of area objects  */
var areas = []
/** global array of latitude edges objects  */
var edgesLat = []
/** global array of longitude edges  objects  */
var edgesLng = []
/** global set of latitudes coincident with Area nodes  */
var gridlinesLatG = new Set()
/** global set of longitudes coincident with Area nodes  */
var gridlinesLngG = new Set()
/** global Circle object whose popup is initiated  */
var activeCircle = []
/** global - current Edge that is being dragged  */
var currentEdge = []
/** global logic  determining if dragging is occuring  */
var isDragging = false
/** array of area objects  */
var areaName0 = []
/** input file edit area */
const areaList = document.getElementById('areaList');
/** status of area list editing  */
var areaListEditing = false
/** undo button */
const undoButton = document.getElementById('undo');
/** status text */
const statusMessage = document.getElementById("statusMessage");

/** add an openstreetmap layer to the map  */
const tiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
})

// add the objects to the map
tiles.addTo(map);
areaLayer.addTo(map)
edgeLayer.addTo(map)

/**
 * keeps tabs on previous actions (last 20) and enables undo of them
 * @class Undo
 */
class Undo {
    constructor() {
        this.list = []
    }
    push(entry) {
        this.list.push(entry)
        undoButton.disabled = false
        if (this.list.length > 20) { this.pop() }
    }
    pop() {
        this.list.pop()
        if (this.list.length == 0) {
            undoButton.disabled = true
        }
    }
    /**
     * undoes the last action by restoring a previous areas.list value 
    */
    undo() {
        // console.log(this.list.length)
        // for (var n = 0; n < this.list.length; n++) {
        //     console.log(n + "-" + this.list[n].split('\n')[0])
        // }
        var areaDef = this.list[this.list.length - 1]
        areaList.value = areaDef
        this.pop()
        readArea(areaDef)
        this.pop() // since readArea created a new undoable action
    }
}
const undo = new Undo();

// set up collapsible blocks
var coll = document.getElementsByClassName("collapsible");
for (var i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function () {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.display === "block") {
            content.style.display = "none";
        } else {
            content.style.display = "block";
        }
        map.invalidateSize(false)

    });
}

// set up file drag and drop
;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    areaList.addEventListener(eventName, preventDefaults, false)
})
function preventDefaults(e) {
    e.preventDefault()
    e.stopPropagation()
}
;['dragenter', 'dragover'].forEach(eventName => {
    areaList.addEventListener(eventName, highlight, false)
})
areaList.addEventListener('beforeinput', (event) => {
    if (!areaListEditing) {
        undo.push(areaList.value)
        areaListEditing = true
    }
})
areaList.addEventListener('change', (event) => {
    areaListEditing = false
})
;['dragleave', 'drop'].forEach(eventName => {
    areaList.addEventListener(eventName, unhighlight, false)
})
function highlight(e) {
    areaList.classList.add('highlight')
}
function unhighlight(e) {
    areaList.classList.remove('highlight')
}
areaList.addEventListener('dragover', (event) => {
    event.stopPropagation();
    event.preventDefault();
    // Style the drag-and-drop as a "copy file" operation.
    event.dataTransfer.dropEffect = 'copy';
    areaList.classList.add('highlight')
});
areaList.addEventListener('drop', (event) => {
    event.stopPropagation();
    event.preventDefault();
    const fileList = event.dataTransfer.files;
    if (fileList.length == 1) {
        console.log(fileList)
        statusMessage.innerHTML = fileList[0].name
        const reader = new FileReader();
        reader.addEventListener('load', (event) => {
            var str = event.target.result;
            undo.push(areaList.value)
            areaList.value = str
            statusMessage.innerHTML += " uploaded successfully."
            statusMessage.classList.add("ok")
            setTimeout(function () { statusMessage.innerHTML = "&nbsp;" }, 4000);
        });
        reader.readAsText(fileList[0]);    
    }
    else {
        statusMessage.innerHTML = "Single file required for drag and drop"
        statusMessage.classList.remove("ok")
        setTimeout(function () { statusMessage.innerHTML = "&nbsp;" }, 4000);
    }
});

/**
 * Writes the output to area.list format
 */
function writeArea() {
    outStr = ''
    for (let area of areas) {
        var thisStr = area.format()
        outStr = outStr + thisStr
    }
    undo.push(areaList.value)
    areaList.value = outStr
}

/**
 * Used for adding new areas
 * @returns mv the maximum number used for the map name
 */
function getMaxMapName() {
    if (areas.length == 0) { return null }
    var mv = 0
    for (let area of areas) {
        mv = Math.max(mv, area.mapName)
    }
    return mv
}

/**
 * read Areas
 * @param {string} fromStr - the area.list to read
 */
function readArea(fromStr) {
    areaLayer.clearLayers()
    areas = []
    var x
    if (fromStr == null) { // call was from a button
        x = (areaList.value)
    }
    else { // call was from an undo 
        x = fromStr
    }
    var lines = x.split("\n")
    for (var n = 0; n < lines.length; ++n) {
        var line = lines[n]
        var entry = line.match(/([^#^:]+): +([0-9-]+),([0-9-]+) +to +([0-9-]+),([0-9-]+)/)
        if (entry != null) {
            //console.log(entry[1])
            var area = new Area(
                parseInt(entry[1]),
                parseInt(entry[2]),
                parseInt(entry[3]),
                parseInt(entry[4]),
                parseInt(entry[5])
            )
            areas.push(area)
        }
        else {
            // check this line is valid
            if (!((line.length == 0) || (line[0] == "#"))) {
                console.log("Bad line: " + line)
                var badline = n + 1
                statusMessage.innerHTML = "Processing failed at line " + badline + ". Check file format."
                statusMessage.classList.add("ok")
                return null
            }

        }
    }
    statusMessage.innerHTML = "Processed " + areas.length + " areas."
    statusMessage.classList.add("ok")
    updateGridlines() // calls writeArea, which would create an additional undo entry
    if (fromStr == null) {
        undo.pop() // remove the additional undo entry
    }
}

/**
 * updateGridlines() moves the grid lines to match the dragged edge line
 */
function updateGridlines() {
    /**
     * METHODOLOGY:
     * 1. Sort the Areas that are coincident with an Edge, based upon their Left (or Lower) coordinate
     * 2. Create an Edge that represents the edge of the first Area
     * 3. Apply logic to determine if the Edge should be so it encompasses the next Area
     * 4. For Areas that are encompassed, store this dependency as part of the properties of the Edge
     * Truth table:
     * 
     * L     R     <- node labels                    | Truth table comparing
     * o-----o     <- OLD edge line (O)              | New and Old nodes:         
     *    NEW line that is coincident (N):           | NL:OL | NL:OR | NR:OR | Outcome
     * o----o      <- start coincident, finishes 1st |   =   |   <   |   <   |  Couple, use OR
     * o-----o     <- start and end coincident       |   =   |   <   |   =   |  Couple, use OR
     *   o-o       <- internal                       |   >   |   <   |   <   |  Couple, use OR
     *     o--o    <- overlaps                       |   >   |   <   |   >   |  Couple, use NR
     *       o--o  <- joined but not overlapped      |   >   |   =   |   >   |  Start new edge
     *         o-o <- not joined                     |   >   |   >   |   >   |  Start new edge
     */
    edgeLayer.clearLayers()
    gridlinesLatG.clear()
    gridlinesLngG.clear()
    edgesLat = []
    egdesLng = []
    for (let area of areas) {
        gridlinesLatG.add(area.latG1).add(area.latG2)
        gridlinesLngG.add(area.lngG1).add(area.lngG2)

    }
    for (let gridlineLatG of gridlinesLatG) {
        var touchingAreas = []
        for (let area of areas) {
            var touches = area.touchesLat(gridlineLatG)
            if (touches == true) {
                touchingAreas.push(area)
            }
        }
        touchingAreas.sort((a, b) => a.lngG1 - b.lngG1)
        var a = null
        var b = null
        var c = null
        var d = null

        for (var n = 0; n < touchingAreas.length; n++) {
            if (n == 0) {
                a = gridlineLatG
                b = touchingAreas[n].lngG1
                c = gridlineLatG
                d = touchingAreas[n].lngG2
                var newEdge = new Edge(a, b, c, d)
                edgesLat.push(newEdge)
                edgesLat[edgesLat.length - 1].addArea(touchingAreas[n])
            }
            else {
                // if contiguoous with the existing edge, then extend the edge
                var new_r = touchingAreas[n].lngG2
                var old_r = edgesLat[edgesLat.length - 1].lngG2
                var new_l = touchingAreas[n].lngG1
                var old_l = edgesLat[edgesLat.length - 1].lngG1
                if (
                    (new_l > old_l) &&
                    (new_l >= old_r) &&
                    (new_r > old_r)) {
                    a = gridlineLatG
                    b = touchingAreas[n].lngG1
                    c = gridlineLatG
                    d = touchingAreas[n].lngG2
                    var newEdge = new Edge(a, b, c, d)
                    edgesLat.push(newEdge)
                    edgesLat[edgesLat.length - 1].addArea(touchingAreas[n])
                }
                else {
                    edgesLat[edgesLat.length - 1].addArea(touchingAreas[n])
                    if (new_r > old_r) {
                        edgesLat[edgesLat.length - 1].extendLng(new_r)
                    }
                }
            }
        }
    }
    for (let gridlineLngG of gridlinesLngG) {
        var touchingAreas = []
        for (let area of areas) {
            var touches = area.touchesLng(gridlineLngG)
            if (touches == true) {
                touchingAreas.push(area)
            }
        }
        touchingAreas.sort((a, b) => a.latG1 - b.latG1)
        var a = null
        var b = null
        var c = null
        var d = null

        for (var n = 0; n < touchingAreas.length; n++) {
            if (n == 0) {
                b = gridlineLngG
                a = touchingAreas[n].latG1
                d = gridlineLngG
                c = touchingAreas[n].latG2
                var newEdge = new Edge(a, b, c, d)
                edgesLng.push(newEdge)
                edgesLng[edgesLng.length - 1].addArea(touchingAreas[n])
            }
            else {
                // if contiguoous with the existing edge, then extend the edge
                var new_r = touchingAreas[n].latG2
                var old_r = edgesLng[edgesLng.length - 1].latG2
                var new_l = touchingAreas[n].latG1
                var old_l = edgesLng[edgesLng.length - 1].latG1
                if (
                    (new_l > old_l) &&
                    (new_l >= old_r) &&
                    (new_r > old_r)) {
                    b = gridlineLngG
                    a = touchingAreas[n].latG1
                    d = gridlineLngG
                    c = touchingAreas[n].latG2
                    var newEdge = new Edge(a, b, c, d)
                    edgesLng.push(newEdge)
                    edgesLng[edgesLng.length - 1].addArea(touchingAreas[n])
                }
                else {
                    edgesLng[edgesLng.length - 1].addArea(touchingAreas[n])
                    if (new_r > old_r) {
                        edgesLng[edgesLng.length - 1].extendLat(new_r)
                    }
                }
            }
        }
    }
    for (let edgeLat of edgesLat) {
        edgeLat.bringToFront()
    }
    for (let edgeLng of edgesLng) {
        edgeLng.bringToFront()
    }
    writeArea()
}

/**
 * generic download function
 * @param {String} filename 
 * @param {String} text 
 */
function download(filename, text) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}
/**
 * specific download function
 */
function downloadNow() {
    download("areas.list", areaList.value)
}
/**
 * generates popup HTML and saves the activeCircle as a global 
 * @returns innerHTML for the popup
 */
function createAreaPopup() {
    activeCircle = this._source
    var mapName
    for (let area of areas) {
        if (area.circle == activeCircle) {
            mapName = area.mapName
        }
    }
    var cont = `
    <style>
    .pop {text-align: center;}
    </style>
    <p style="pop">
    Map Area ID: ${mapName} </p>
    <p>
    <input type="button" class="bin"      onclick="deleteArea()"      value="&#x1F5D1;" title="Delete this map area">
    <input type="button" class="normal"   onclick="splitHorizontal()" value="&#9707;"   title="Split this area horizontally">
    <input type="button" class="rotate90" onclick="splitVertical()"   value ="&#9707;"  title="Split this area vertically">
    </p>
    `
    return cont
}

/**
 * deletes an area and closes the popup
 */
function deleteArea() {
    for (let area of areas) {
        if (area.circle == activeCircle) {
            areaLayer.removeLayer(area.circle)
            areaLayer.removeLayer(area)
            ind = areas.indexOf(area)
            areas.splice(ind, 1)
            updateGridlines()
            activeCircle.closePopup()
        }
    }
}

/**
 * split the area vertically and close the popup
 */
function splitVertical() {
    for (let area of areas) {
        if (area.circle == activeCircle) {
            var latG1 = area.latG1
            var lngG1 = area.lngG1
            var latG2 = area.latG2
            var lngG2 = area.lngG2
            var latM = Math.round((latG1 + latG2) / 2 / 2048) * 2048
            if ((latM == latG1) || (latM == latG2)) {
                alert('Area too small to split')
                activeCircle.closePopup()
                return
            }

            var area1 = new Area(getMaxMapName() + 1, latG1, lngG1, latM, lngG2)
            var area2 = new Area(getMaxMapName() + 2, latM, lngG1, latG2, lngG2)

            areas.push(area1)
            areas.push(area2)
            areaLayer.removeLayer(area.circle)
            areaLayer.removeLayer(area)

            ind = areas.indexOf(area)
            areas.splice(ind, 1)
            updateGridlines()
            activeCircle.closePopup()
        }
    }
}

/**
 * split the area horizontally and closes the popup
 */
function splitHorizontal() {
    for (let area of areas) {
        if (area.circle == activeCircle) {
            var latG1 = area.latG1
            var lngG1 = area.lngG1
            var latG2 = area.latG2
            var lngG2 = area.lngG2
            var lngM = Math.round(((lngG1 + lngG2) / 2) / 2048) * 2048
            if ((lngM == lngG1) || (lngM == lngG2)) {
                alert('Area too small to split')
                activeCircle.closePopup()
                return
            }

            var area1 = new Area(getMaxMapName() + 1, latG1, lngG1, latG2, lngM)
            var area2 = new Area(getMaxMapName() + 2, latG1, lngM, latG2, lngG2)

            areas.push(area1)
            areas.push(area2)
            areaLayer.removeLayer(area.circle)
            areaLayer.removeLayer(area)

            ind = areas.indexOf(area)
            areas.splice(ind, 1)
            updateGridlines()
            activeCircle.closePopup()
        }
    }
}

/**
 * convert from Garmin units to Latitude or Longitude
 * @param {int} gmn - value in garmin units
 * @returns  - value in degrees
 */
function toLatLng(gmn) {
    const scale = (2 ** 24) / 360.0
    return (gmn + 0.0) / scale
}

/**
 * convert from Garmin units to Latitude or Longitude
 * @param {int} deg - value in degrees
 * @returns  - value in garmin Units
 */
function toGmn(deg) {
    const scale = (2 ** 24) / 360
    var g = Math.round(deg * scale)
    g = 2048 * (Math.round(g / 2048))
    return g
}

/**
 * represents a map, i.e. one of the areaas created by splitter
 * @class
 */
class Area extends L.Rectangle {
    constructor(mapName, latG1, lngG1, latG2, lngG2) {
        var c1 = L.latLng(toLatLng(latG1), toLatLng(lngG1))
        var c2 = L.latLng(toLatLng(latG2), toLatLng(lngG2))
        super([c1, c2])
        this.mapName = mapName
        this.latG1 = latG1
        this.lngG1 = lngG1
        this.latG2 = latG2
        this.lngG2 = lngG2
        areaLayer.addLayer(this)
        // this.addTo(map)
        var cen = L.latLng((c1.lat + c2.lat) / 2, (c1.lng + c2.lng) / 2)

        this.circle = L.circle(cen, {
            color: 'blue',
            fillColor: '#00f',
            fillOpacity: 0.5,
            radius: 500
        })
        var contents = '<button type="button" onclick="hello()">Delete</button>'
        areaLayer.addLayer(this.circle)
        this.circle.bindPopup(createAreaPopup);
    }
    /**
     * @returns formatted string for writing the area.l
     */
    format() {
        var str = `${this.mapName}: ${this.latG1},${this.lngG1} to ${this.latG2},${this.lngG2} \n`
        return str
    }
    /**
     * check an area is not going to become 'negative' by changing its geometry
     * @param {Int} oldLatOrLngG - previous value
     * @param {Int} newLatOrLngG - new value 
     * @param {Boolean} isLat - true if the values are Latitudes
     * @returns 
     */
    checkPositive(oldLatOrLngG, newLatOrLngG, isLat) {
        if (isLat) {
            if (oldLatOrLngG == this.latG1) { //latG1 has changed... check its less that latG2
                return (newLatOrLngG < this.latG2)
            }
            else if (oldLatOrLngG == this.latG2) { //latG2 has changed... check > G1
                return (newLatOrLngG > this.latG1)
            }
            else {
                console.error('mismatched lat');
            }
        }
        else {
            if (oldLatOrLngG == this.lngG1) {
                return (newLatOrLngG < this.lngG2)
            }
            else if (oldLatOrLngG == this.lngG2) {
                return (newLatOrLngG > this.lngG1)
            }
            else {
                console.error('mismatched lng');
            }
        }
    }
    /**
     * change an area's Latitude 
     * @param {Int} oldLatOrLngG - previous value
     * @param {Int} newLatOrLngG - new value 
     */
    changeLat(oldLatG, newLatG) {
        var c1
        var c2
        if (oldLatG == this.latG1) {
            this.latG1 = newLatG
        }
        else if (oldLatG == this.latG2) {
            this.latG2 = newLatG
        }
        else {
            console.error('mismatched lat');
        }
        c1 = L.latLng(toLatLng(this.latG1), toLatLng(this.lngG1))
        c2 = L.latLng(toLatLng(this.latG2), toLatLng(this.lngG2))
        this.setBounds([c1, c2])
        var cen = L.latLng((c1.lat + c2.lat) / 2, (c1.lng + c2.lng) / 2)
        this.circle.setLatLng(cen)
    }
    /**
     * change an area's Longitude 
     * @param {Int} oldLatOrLngG - previous value
     * @param {Int} newLatOrLngG - new value 
     */
    changeLng(oldLngG, newLngG) {
        var c1
        var c2
        if (oldLngG == this.lngG1) {
            this.lngG1 = newLngG
        }
        else if (oldLngG == this.lngG2) {
            this.lngG2 = newLngG
        }
        else {
            console.error('mismatched lng');
        }
        c1 = L.latLng(toLatLng(this.latG1), toLatLng(this.lngG1))
        c2 = L.latLng(toLatLng(this.latG2), toLatLng(this.lngG2))
        this.setBounds([c1, c2])
        var cen = L.latLng((c1.lat + c2.lat) / 2, (c1.lng + c2.lng) / 2)
        this.circle.setLatLng(cen)
    }

    /**
     * check if the area touches a Latitude line
     * @param {Int} intVal - Latitude in garmin units 
     * @returns True if touches
     */
    touchesLat(intVal) {
        return ((intVal == this.latG1) | (intVal == this.latG2))
    }
    /**
     * check if the area touches a Longitude line
     * @param {Int} intVal - Latitude in garmin units 
     * @returns True if touches
     */
    touchesLng(intVal) {
        return ((intVal == this.lngG1) | (intVal == this.lngG2))
    }
}

/**
 * represents a contiguous edge that spans one or more edges of an area
 */
class Edge extends L.Polyline {
    /**
     * extend latitude
     * @param {Int} newLatG2 
     */
    extendLat(newLatG2) {
        this.latG2 = newLatG2
        var c1 = L.latLng(toLatLng(this.latG1), toLatLng(this.lngG1))
        var c2 = L.latLng(toLatLng(newLatG2), toLatLng(this.lngG2))
        this.setLatLngs([c1, c2])
        this.end2.setLatLng(c2)
    }
    /**
     * extend longitude
     * @param {Int} newLngG2 
     */
    extendLng(newLngG2) {
        this.lngG2 = newLngG2
        var c1 = L.latLng(toLatLng(this.latG1), toLatLng(this.lngG1))
        var c2 = L.latLng(toLatLng(this.latG2), toLatLng(newLngG2))
        this.setLatLngs([c1, c2])
        this.end2.setLatLng(c2)
    }
    /**
     * add another area to the edge's dependent areas
     * @param {Area} area 
     */
    addArea(area) {
        this.areas.push(area)
    }

    /**
     * update the boundaries of each area that is a dependency
     */
    updateAreas() {
        var oldState = this.state
        var newState = this.isLat ? this.latG1 : this.lngG1
        var ok = true
        for (let area of this.areas) {
            ok = (area.checkPositive(oldState, newState, this.isLat) && ok)
        }
        if (!(ok)) {
            statusMessage.innerHTML = "Edit cancelled as an area would become negative."
            statusMessage.classList.remove("ok")
            setTimeout(function () { statusMessage.innerHTML = "&nbsp;" }, 4000);
            return
        }

        for (let area of this.areas) {
            if (this.isLat) {
                area.changeLat(oldState, newState)
            }
            else {
                area.changeLng(oldState, newState)
            }
            // get the bound that matched the old state, and set it to the new state

        }
    }
    /**
     * `state` is stored prior to a drag event
     * and used to check changes to the dependent areas
     */
    saveState() {
        if (this.isLat) {
            this.state = this.latG1
        }
        else {
            this.state = this.lngG1
        }
    }

    /**
     * @constructor
     * @param {Int} latG1 - coordinates
     * @param {Int} lngG1 - coordinates
     * @param {Int} latG2 - coordinates
     * @param {Int} lngG2 - coordinates
     */
    constructor(latG1, lngG1, latG2, lngG2) {
        var c1 = L.latLng(toLatLng(latG1), toLatLng(lngG1))
        var c2 = L.latLng(toLatLng(latG2), toLatLng(lngG2))
        super([c1, c2], { color: 'red', weight: 5, opacity: 0.5 })
        this.isLat = (latG1 == latG2)
        this.areas = []
        this.latG1 = latG1
        this.lngG1 = lngG1
        this.latG2 = latG2
        this.lngG2 = lngG2
        this.state = null
        this.end1 = L.circle(c1, { color: 'red' })
        this.end2 = L.circle(c2, { color: 'red' })
        edgeLayer.addLayer(this)
        edgeLayer.addLayer(this.end1)
        edgeLayer.addLayer(this.end2)
        /**
         * mousdown functionality is set here...
         * on mousedown over the Edge,
         *   save the state
         *   set dragging to true
         *   then create a mousemove event for the whole map
         * the mousemove eveent allows the Edge to move in garmin unit multiples
         * the mouseup event then triggers an update to the Edge's dependent areas
         * after this ALL Edges are recalculated as the dependencies might have changed.
         * this is done via the updateGridlines() global function
         */
        this.on({
            mousedown: function (e) {
                currentEdge = this
                this.saveState()
                isDragging = true
                map.on('mousemove', function (e) {
                    map.dragging.disable();
                    var point = e.latlng
                    if (currentEdge.isLat) {
                        var p1lat = e.latlng.lat
                        currentEdge.latG1 = toGmn(p1lat)
                        currentEdge.latG2 = toGmn(p1lat)
                        p1lat = toLatLng(currentEdge.latG1)
                        var p1lng = toLatLng(currentEdge.lngG1)
                        var p2lat = p1lat
                        var p2lng = toLatLng(currentEdge.lngG2)
                    }
                    else {
                        var p1lng = e.latlng.lng
                        currentEdge.lngG1 = toGmn(p1lng)
                        currentEdge.lngG2 = toGmn(p1lng)
                        p1lng = toLatLng(currentEdge.lngG1)
                        var p1lat = toLatLng(currentEdge.latG1)
                        var p2lng = p1lng
                        var p2lat = toLatLng(currentEdge.latG2)
                    }
                    var p1 = L.latLng(p1lat, p1lng)
                    var p2 = L.latLng(p2lat, p2lng)
                    currentEdge.setLatLngs([p1, p2]);
                    currentEdge.end1.setLatLng(p1);
                    currentEdge.end2.setLatLng(p2);

                });
                map.on('mouseup', function (e) {
                    map.removeEventListener('mousemove');
                    map.dragging.enable();
                    if (isDragging) {
                        isDragging = false
                        currentEdge.updateAreas()
                        updateGridlines()
                    }
                });
            }
        });
    }
}


    </script>
</body>

</html>